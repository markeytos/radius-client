/*
Copyright Â© 2024 Keytos alan@keytos.io

Define MS-CHAPv2 cryptographic operations
*/
package mschapv2

import (
	"crypto/des"
	"crypto/sha1"
	"log"
	"unicode/utf16"

	// nolint:staticcheck // SA1019 protocol requires MD4
	"golang.org/x/crypto/md4"
)

func ChallengeHash(peerc, authc []byte, uname string) []byte {
	if len(peerc) != 16 {
		log.Fatal("peer challenge must be of size 16")
	}
	if len(authc) != 16 {
		log.Fatal("authentication  challenge must be of size 16")
	}

	h := sha1.New()
	h.Write(peerc)
	h.Write(authc)
	h.Write([]byte(uname))
	return h.Sum(nil)[:8]
}

func WriteNTResponse(dst, pwh, chall []byte) {
	if len(dst) != 24 {
		log.Fatal("destination slice must be of size 24")
	}
	if len(chall) != 8 {
		log.Fatal("destination slice must be of size 8")
	}

	zpw := make([]byte, 21)
	copy(zpw, pwh)

	cb, _ := des.NewCipher(withParityBits(zpw[0:7]))
	cb.Encrypt(dst[:8], chall)

	cb, _ = des.NewCipher(withParityBits(zpw[7:14]))
	cb.Encrypt(dst[8:16], chall)

	cb, _ = des.NewCipher(withParityBits(zpw[14:21]))
	cb.Encrypt(dst[16:], chall)
}

var responseMagic1 = [...]byte{
	0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x73, 0x65,
	0x72, 0x76, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20,
	0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x73,
	0x69, 0x67, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x63,
	0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74,
}
var responseMagic2 = [...]byte{
	0x50, 0x61, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6D,
	0x61, 0x6B, 0x65, 0x20, 0x69, 0x74, 0x20, 0x64,
	0x6F, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74,
	0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E, 0x65, 0x20,
	0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
	0x6E,
}

func AuthenticatorResponse(pwhh, ntResponse, challengeHash []byte) []byte {
	h := sha1.New()
	h.Write(pwhh)
	h.Write(ntResponse)
	h.Write(responseMagic1[:])
	s := h.Sum(nil)

	h.Reset()
	h.Write(s)
	h.Write(challengeHash)
	h.Write(responseMagic2[:])

	return h.Sum(nil)
}

var shsPad1 = [...]byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}
var shsPad2 = [...]byte{
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
}
var keyDerivationMagic1 = [...]byte{
	0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74,
	0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d,
	0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79,
}
var keyDerivationMagic2 = [...]byte{
	0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
	0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79,
	0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
	0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65,
	0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
	0x6b, 0x65, 0x79, 0x2e,
}
var keyDerivationMagic3 = [...]byte{
	0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69,
	0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20,
	0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20,
	0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68,
	0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73,
	0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
	0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20,
	0x6b, 0x65, 0x79, 0x2e,
}

func SessionKeys(pwhh, ntResponse []byte) (recvKey, sendKey []byte) {
	h := sha1.New()
	h.Write(pwhh)
	h.Write(ntResponse)
	h.Write(keyDerivationMagic1[:])
	masterKey := h.Sum(nil)[:16]

	h.Reset()
	h.Write(masterKey)
	h.Write(shsPad1[:])
	h.Write(keyDerivationMagic2[:])
	h.Write(shsPad2[:])
	recvKey = h.Sum(nil)[:16]

	h.Reset()
	h.Write(masterKey)
	h.Write(shsPad1[:])
	h.Write(keyDerivationMagic3[:])
	h.Write(shsPad2[:])
	sendKey = h.Sum(nil)[:16]

	return
}

func withParityBits(k []byte) []byte {
	if len(k) != 7 {
		log.Fatal("key must be 56 bits")
	}
	newKey := make([]byte, 8)
	newKey[0] = k[0] & 0xfe
	newKey[1] = (k[0]<<7 | k[1]>>1) & 0xfe
	newKey[2] = (k[1]<<6 | k[2]>>2) & 0xfe
	newKey[3] = (k[2]<<5 | k[3]>>3) & 0xfe
	newKey[4] = (k[3]<<4 | k[4]>>4) & 0xfe
	newKey[5] = (k[4]<<3 | k[5]>>5) & 0xfe
	newKey[6] = (k[5]<<2 | k[6]>>6) & 0xfe
	newKey[7] = (k[6] << 1) & 0xfe
	return newKey
}

func Utf16Bytes(s string) []byte {
	b := make([]byte, 0, len(s)*2)
	for _, r := range utf16.Encode([]rune(s)) {
		b = append(b, byte(r&0xff), byte(r>>8))
	}
	return b
}

func NTPasswordHash(pw []byte) []byte {
	h := md4.New()
	h.Write(pw)
	return h.Sum(nil)
}
